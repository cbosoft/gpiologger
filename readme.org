#+TITLE: Readme

Logs GPIO to file

Very fast =c= implementation with very little error checking 
and no GPIO initialisation. Intended to be used as a sub 
program within a slower wrapper program (i.e. a python script).

* Installation

  - Clone the repository to your Raspberry Pi and =cd= into it.
  - run =make= and it should build the default version of the 
    logger.

* Example usage
  In python, set up the GPIO:

  #+BEGIN_SRC python :tangle example_usage.py
import subprocess as sp
import RPi.GPIO as gpio

pins = [16, 20, 21]

gpio.setmode(gpio.BCM)

for pin in pins:
    gpio.setup(pin, gpio.IN, pull_up_down=gpio.PUD_UP)

logfiles = [f'gpio_pin{}.csv' for pin in pins]
  #+END_SRC

  Then run the =c= logger:

  #+BEGIN_SRC python :tangle example_usage.py
pr = sp.Popen(['./gpiologger', *logfiles])
  #+END_SRC

  The logger will continue to run until it is told to stop, 
  constantly appending to the log file. Do whatever you want 
  to do while the logging is underway, it is happening in 
  another process and should not impact the running of your 
  script.

  #+BEGIN_SRC python :tangle example_usage.py
import time

for i in range(60):
    time.sleep(100)
  #+END_SRC

  Then, once you're finished, kill the logger and cleanup 
  the GPIO.

  #+BEGIN_SRC python :tangle example_usage.py
pr.kill()
gpio.cleanup()
  #+END_SRC

* Result

  A CSV containing the time when the gpio value changed.
* Issues

  - mtime based logger (=mtl.c=) doesn't output, does the GPIO 
    value file not adhere to modification time update rules?
